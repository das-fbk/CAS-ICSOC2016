package eu.fbk.das.adaptation.presentation;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Label;
import java.util.List;
import java.util.Vector;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.ListSelectionModel;
import javax.swing.table.DefaultTableModel;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.mxgraph.layout.mxGraphLayout;
import com.mxgraph.layout.hierarchical.mxHierarchicalLayout;
import com.mxgraph.model.mxGraphModel;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.view.mxGraph;

import eu.fbk.das.adaptation.EnsembleManager;
import eu.fbk.das.adaptation.ensemble.Ensemble;
import eu.fbk.das.adaptation.model.IssueResolution;
import eu.fbk.das.adaptation.presentation.action.IssueTableSelectionListener;
import eu.fbk.das.adaptation.presentation.action.MouseTreeNodeListener;
import eu.fbk.das.adaptation.presentation.action.RankedSolutionTableSelectionListener;

public class CAWindow extends JFrame {

    private static final Logger logger = LogManager.getLogger(CAWindow.class);
    private static final long serialVersionUID = -2707712944901661771L;

    public int counter = 0;

    // main frame
    public JFrame frame;

    public JPanel treePanel;

    // main window components

    private JPanel mainPanel;

    private Label label;

    // private JList<String> IssueResolutionsList;
    private JTable IssueResolutionsList;

    private JTable PossibleSolutionList;
    private JTable EstimatedSolutionList;

    private JTable analyzerLog;
    private JTable monitorList;
    private JTable planningList;
    private JTable executeList;

    private List<EnsembleManager> ensm;

    private mxGraphLayout layout;
    private JButton btnStep;

    private JTextArea logTextArea;

    private JScrollPane activeIssuesScrollPane;
    private JScrollPane PossibleSolutionScrollPane;
    private JScrollPane EstimatedSolutionScrollPane;
    private JScrollPane CATreeScrollPane;
    private JScrollPane activeMonitorScrollPane;
    private JScrollPane analyzerLogScrollPane;
    private JScrollPane plannerLogScrollPane;
    private JScrollPane executeLogScrollPane;
    private mxGraphComponent graphComponent;

    public mxGraphComponent getGraphComponent() {
	return graphComponent;
    }

    public void setGraphComponent(mxGraphComponent graphComponent) {
	this.graphComponent = graphComponent;
    }

    private JScrollPane treeScrollPanel;

    public CAWindow(List<EnsembleManager> ems) {

	super("Collective Adaptation Viewer");
	BorderLayout borderLayout = (BorderLayout) getContentPane().getLayout();
	borderLayout.setVgap(10);
	borderLayout.setHgap(10);

	this.ensm = ems;

	mainPanel = new JPanel();
	mainPanel.setVisible(true);
	// mettere solo preferredSize per far comparire le barre di scorrimento
	// verticali
	mainPanel.setPreferredSize(new Dimension(1124, 1300));
	mainPanel.setLayout(new BorderLayout(0, 0));

	label = new Label("Select an active Issue Resolution to see its collective adaptation resolution tree");
	mainPanel.add(label, BorderLayout.NORTH);

	// Log Text ARea
	// Label lblLog = new Label("Execution Log");
	// lblLog.setBounds(10, 550, 223, 22);
	// mainPanel.add(lblLog);

	// log inside a scrollpane logTextArea = new JTextArea("");
	// logTextArea = new JTextArea();
	// logTextArea.setBounds(10, 575, 982, 120);
	// logTextArea.setEditable(false);
	// JScrollPane logScrollPane = new JScrollPane(logTextArea);
	// logScrollPane.setBounds(10, 580, 982, 120);
	// mainPanel.add(logScrollPane);

	getContentPane().add(mainPanel);

	// window to show issue tables and trees

	Vector<String> columnNames = new Vector<String>();
	columnNames.add("N");
	columnNames.add("CAP ID");
	columnNames.add("Role");
	columnNames.add("Issue");
	columnNames.add("Issue Status");
	columnNames.add("Ensemble");

	IssueResolutionsList = new JTable(null, columnNames);

	// TEST PRO-EDITING CON WINDOW BUILDER
	// {
	// @Override
	// public boolean isCellEditable(int r, int c) {
	// return false; // Disallow the editing of any cell
	// }
	//
	// };

	IssueResolutionsList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
	IssueResolutionsList.setBounds(5, 125, 600, 400);
	IssueResolutionsList.setFillsViewportHeight(true);

	IssueResolutionsList.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
	// IssueResolutionsList.getSelectionModel()
	// .addListSelectionListener(new
	// IssueTableSelectionListener(IssueResolutionsList, em, this));

	JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	tabbedPane.setPreferredSize(new Dimension(500, 600));
	tabbedPane.setMinimumSize(new Dimension(400, 400));
	mainPanel.add(tabbedPane, BorderLayout.WEST);

	activeIssuesScrollPane = new JScrollPane(IssueResolutionsList);
	tabbedPane.addTab("Active Issue Resolutions", null, activeIssuesScrollPane, null);
	tabbedPane.setEnabledAt(0, true);

	// Load Trees Frame
	CATree cat = new CATree();
	// frame to see the issue resolution tree mxGraphComponent
	graphComponent = new mxGraphComponent(cat);

	// layout = new mxParallelEdgeLayout(graphComponent.getGraph());

	// layout = new mxHierarchicalLayout(graphComponent.getGraph());
	// layout = new mxCompactTreeLayout(graphComponent.getGraph());

	graphComponent.setEnabled(false);

	graphComponent.getGraphControl().addMouseListener(new MouseTreeNodeListener(graphComponent, this.ensm, this));

	graphComponent.setBounds(600, 125, 650, 600);
	graphComponent.setBorder(javax.swing.BorderFactory.createLineBorder(new Color(0, 0, 0)));

	// layout.execute(graphComponent.getGraph().getDefaultParent());

	JTabbedPane tabbedPaneTree = new JTabbedPane(JTabbedPane.TOP);
	tabbedPaneTree.setPreferredSize(new Dimension(800, 800));
	tabbedPaneTree.setMinimumSize(new Dimension(5, 800));
	mainPanel.add(tabbedPaneTree, BorderLayout.CENTER);

	CATreeScrollPane = new JScrollPane(graphComponent);
	tabbedPaneTree.addTab("Issue Resolution Tree", null, CATreeScrollPane, null);
	tabbedPaneTree.setEnabledAt(0, true);

	// PREDICTION, FEASABILITY, RANKING
	Vector<String> SolutionsColumnNames = new Vector<String>();
	SolutionsColumnNames.add("IssueType");
	SolutionsColumnNames.add("Predicted Solution");
	SolutionsColumnNames.add("Success Rate");
	SolutionsColumnNames.add("Feasibility");
	SolutionsColumnNames.add("Ranking");

	PossibleSolutionList = new JTable(null, SolutionsColumnNames) {
	    @Override
	    public boolean isCellEditable(int r, int c) {
		return false; // Disallow the editing of any cell
	    }

	};

	PossibleSolutionList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
	PossibleSolutionList.setBounds(10, 520, 40, 22);
	PossibleSolutionList.setFillsViewportHeight(true);
	PossibleSolutionList.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
	// TAB FOR SOLUTION PRUNING AND RANKING

	JTabbedPane tabbedPaneNew = new JTabbedPane(JTabbedPane.TOP);
	tabbedPaneNew.setPreferredSize(new Dimension(5, 200));
	tabbedPaneNew.setMaximumSize(new Dimension(32767, 400));

	PossibleSolutionScrollPane = new JScrollPane(PossibleSolutionList);
	tabbedPaneNew.addTab("PREDICTION, FEASIBILITY, RANKING", null, PossibleSolutionScrollPane, null);
	tabbedPaneNew.setEnabledAt(0, true);

	// tabbedPaneNew.addTab("Feasibility Filtering", null, null, null);
	// tabbedPaneNew.setEnabledAt(0, true);

	// tabbedPaneNew.addTab("Solutions Ranking", null, null, null);
	// tabbedPaneNew.setEnabledAt(0, true);

	mainPanel.add(tabbedPaneNew, BorderLayout.SOUTH);

	// TAB FOR HIERARCHICAL ENSEMBLES
	JTabbedPane tabbedPaneHierarchy = new JTabbedPane(JTabbedPane.TOP);
	tabbedPaneHierarchy.setPreferredSize(new Dimension(5, 200));
	tabbedPaneHierarchy.setMaximumSize(new Dimension(32767, 400));

	// PossibleSolutionScrollPane = new JScrollPane(PossibleSolutionList);
	tabbedPaneHierarchy.addTab("xxx", null, PossibleSolutionScrollPane, null);
	tabbedPaneHierarchy.setEnabledAt(0, true);

	mainPanel.add(tabbedPaneHierarchy, BorderLayout.SOUTH);

	// /////////////////
	this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	this.setSize(1024, 768);

	this.setVisible(true);

    }

    private Vector<String> convertAndFilterForJtablePossibleSolution(RankedSolution rs) {

	// here we print the Evoknowledge estimation
	// for a certain issue type

	Vector<String> v = new Vector<String>();

	v.add(rs.getIssueType());
	v.add(rs.getSolution());
	Double x = rs.getPrediction().getEstimatedSuccessrate();
	String rate = String.format("%.2f", x);

	v.add(rate);
	v.add(rs.getFeasible());
	v.add(rs.getRanking());

	return v;
    }

    private Vector<String> convertAndFilterForJtable(String counter, String capID, IssueResolution ir,
	    EnsembleManager em) {
	// Vector<String> response = new Vector<String>();

	Vector<String> v = new Vector<String>();
	v.add(counter);
	v.add(capID);
	v.add(ir.getRoleCurrent().getRole().getType());
	v.add(ir.getIssueInstance().getIssueType());
	v.add(ir.getStatus());
	v.add(em.getEnsemble().getName());

	return v;
    }

    private Vector<Vector<String>> convertPlannerForJtable(List<String> plans) {
	Vector<Vector<String>> response = new Vector<Vector<String>>();
	/*
	 * for (IssueResolution ir : issueResolutions) { Vector<String> v = new
	 * Vector<String>(); v.add(ir.getRoleCurrent().getType());
	 * v.add(ir.getIssueInstance().getType());
	 * 
	 * response.add(v);
	 * 
	 * }
	 */
	return response;
    }

    private Vector<Vector<String>> convertExecuteForJtable(List<String> executes) {
	Vector<Vector<String>> response = new Vector<Vector<String>>();
	/*
	 * for (IssueResolution ir : issueResolutions) { Vector<String> v = new
	 * Vector<String>(); v.add(ir.getRoleCurrent().getType());
	 * v.add(ir.getIssueInstance().getType());
	 * 
	 * response.add(v);
	 * 
	 * }
	 */
	return response;
    }

    private Vector<Vector<String>> convertAnalyzerForJtable(List<String> logs) {
	Vector<Vector<String>> response = new Vector<Vector<String>>();
	/*
	 * for (IssueResolution ir : issueResolutions) { Vector<String> v = new
	 * Vector<String>(); v.add(ir.getRoleCurrent().getType());
	 * v.add(ir.getIssueInstance().getType());
	 * 
	 * response.add(v);
	 * 
	 * }
	 */
	return response;
    }

    private Vector<Vector<String>> convertMonitorForJtable(List<String> monitors) {
	Vector<Vector<String>> response = new Vector<Vector<String>>();
	/*
	 * for (IssueResolution ir : issueResolutions) { Vector<String> v = new
	 * Vector<String>(); v.add(ir.getRoleCurrent().getType());
	 * v.add(ir.getIssueInstance().getType());
	 * 
	 * response.add(v);
	 * 
	 * }
	 */
	return response;
    }

    public void loadCATree(CATree cat) {

	if (cat == null) {
	    cat = new CATree();
	    // frame to see the issue resolution tree mxGraphComponent
	    graphComponent = new mxGraphComponent(cat);
	    // layout = new mxParallelEdgeLayout(graphComponent.getGraph());

	    layout = new mxHierarchicalLayout(graphComponent.getGraph());

	    // graphComponent.setBounds(280, 125, 400, 400);
	    graphComponent.setBorder(javax.swing.BorderFactory.createLineBorder(new Color(0, 0, 0)));

	    graphComponent.setEnabled(true);
	    layout.execute(graphComponent.getGraph().getDefaultParent());

	    JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	    // tabbedPane.setBounds(280, 125, 400, 400);
	    mainPanel.add(tabbedPane);

	    CATreeScrollPane = new JScrollPane(graphComponent);
	    tabbedPane.addTab("Issue Resolution Tree", null, CATreeScrollPane, null);
	    tabbedPane.setEnabledAt(0, true);

	    refreshWindow();

	} else {

	    // frame to see the issue resolution tree mxGraphComponent
	    graphComponent = new mxGraphComponent(cat);

	    // layout = new mxParallelEdgeLayout(graphComponent.getGraph());

	    layout = new mxHierarchicalLayout(graphComponent.getGraph());

	    // graphComponent.setBounds(280, 125, 400, 400);
	    graphComponent.setBorder(javax.swing.BorderFactory.createLineBorder(new Color(0, 0, 0)));

	    graphComponent.setEnabled(true);
	    layout.execute(cat.getDefaultParent());

	    JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	    // tabbedPane.setBounds(280, 125, 400, 400);
	    mainPanel.add(tabbedPane);

	    CATreeScrollPane = new JScrollPane(graphComponent);
	    tabbedPane.addTab("Issue Resolution Tree", null, CATreeScrollPane, null);
	    tabbedPane.setEnabledAt(0, true);

	    refreshWindow();
	}

    }

    /*
     * public void displayTree(CATree cat) { if (cat == null) { logger.warn(
     * "CA Tree be not null"); return; } // display process Model if (cat ==
     * null) { cat = new CATree(); this.treePanel.setLayout(new
     * GridBagLayout()); JScrollPane treeScrollPane = new
     * JScrollPane(treePanel); treeScrollPane.setBounds(247, 447, 586, 200);
     * treeScrollPane.setBorder(new LineBorder(new Color(0, 0, 0)));
     * 
     * mainPanel.add(treeScrollPane);
     * 
     * } this.clearTree(); this.updateTree(cat);
     * 
     * refreshWindow(); }
     */
    /**
     * Clear graph
     * 
     * @see {@link mxGraphModel#clear}
     */
    public void clearTree() {
	mxGraph current = graphComponent.getGraph();
	((mxGraphModel) current.getModel()).clear();

    }

    public void updateTree(CATree tree) {

	graphComponent.setGraph(tree);

	layout = new mxHierarchicalLayout(graphComponent.getGraph());

	layout.execute(graphComponent.getGraph().getDefaultParent());
	graphComponent.repaint();

    }

    public void loadTreeFrame() {

	CATree cat = new CATree();
	// frame to see the issue resolution tree mxGraphComponent
	graphComponent = new mxGraphComponent(cat);
	// layout = new mxParallelEdgeLayout(graphComponent.getGraph());

	// layout = new mxHierarchicalLayout(graphComponent.getGraph());

	graphComponent.getGraphControl().addMouseListener(new MouseTreeNodeListener(graphComponent, this.ensm, this));

	graphComponent.setBounds(420, 125, 400, 400);
	graphComponent.setBorder(javax.swing.BorderFactory.createLineBorder(new Color(0, 0, 0)));

	graphComponent.setEnabled(true);
	// layout.execute(graphComponent.getGraph().getDefaultParent());

	JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	tabbedPane.setBounds(420, 125, 400, 400);
	mainPanel.add(tabbedPane);

	CATreeScrollPane = new JScrollPane(graphComponent);
	tabbedPane.addTab("Issue Resolution Tree", null, CATreeScrollPane, null);
	tabbedPane.setEnabledAt(0, true);
    }

    public void loadAnalyzerFrame(List<String> logs, Ensemble e) {
	Vector<Vector<String>> data = convertAnalyzerForJtable(logs);
	// List of Active Issue Resolutions
	Vector<String> columnNames = new Vector<String>();
	columnNames.add("State");

	analyzerLog = new JTable(data, columnNames) {
	    @Override
	    public boolean isCellEditable(int r, int c) {
		return false; // Disallow the editing of any cell
	    }

	};
	analyzerLog.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
	analyzerLog.setBounds(640, 310, 200, 130);
	analyzerLog.setFillsViewportHeight(true);

	JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	tabbedPane.setBounds(640, 310, 200, 130);
	mainPanel.add(tabbedPane);

	analyzerLogScrollPane = new JScrollPane(analyzerLog);
	tabbedPane.addTab("Analyzing", null, analyzerLogScrollPane, null);
	tabbedPane.setEnabledAt(0, true);

	refreshWindow();
    }

    public void loadMonitoringTable(List<String> activeMonitors, Ensemble e) {
	Vector<Vector<String>> data = convertMonitorForJtable(activeMonitors);
	// List of Active Issue Resolutions
	Vector<String> columnNames = new Vector<String>();
	columnNames.add("Monitor");
	columnNames.add("State");

	monitorList = new JTable(data, columnNames) {
	    @Override
	    public boolean isCellEditable(int r, int c) {
		return false; // Disallow the editing of any cell
	    }

	};
	monitorList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
	monitorList.setBounds(640, 125, 200, 130);
	monitorList.setFillsViewportHeight(true);

	JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	tabbedPane.setBounds(640, 125, 200, 130);
	mainPanel.add(tabbedPane);

	activeMonitorScrollPane = new JScrollPane(monitorList);
	tabbedPane.addTab("Monitoring", null, activeMonitorScrollPane, null);
	tabbedPane.setEnabledAt(0, true);

	refreshWindow();
    }

    // method to update the tab of the possible solutions (Evoknowledge)
    public void updatePossibleSolutions(EnsembleManager em, List<RankedSolution> rs) {

	for (int i = 0; i < rs.size(); i++) {
	    Vector<String> row = convertAndFilterForJtablePossibleSolution(rs.get(i));

	    ((DefaultTableModel) PossibleSolutionList.getModel()).addRow(row);
	    PossibleSolutionList.getSelectionModel()
		    .addListSelectionListener(new RankedSolutionTableSelectionListener(PossibleSolutionList, em, this));
	}

    }

    public void updateResolutions(String capID, IssueResolution issue, EnsembleManager em) {

	this.counter = this.counter + 1;
	String counter = Integer.toString(this.counter);
	EnsembleManager e = issue.getRoleCurrent().getEnsemble();
	Vector<String> row = convertAndFilterForJtable(counter, capID, issue, e);
	// //System.out.println(row);
	// for (Ensemble ensemble : ensembles) {
	// Vector<String> v = new Vector<String>();
	// v.add(ensemble.getName());
	// data.add(v);
	// }

	Vector<String> columnNames = new Vector<String>();
	columnNames.add("N");
	columnNames.add("CAP ID");
	columnNames.add("Role");
	columnNames.add("Issue");
	columnNames.add("Issue Status");
	columnNames.add("Ensemble");

	((DefaultTableModel) IssueResolutionsList.getModel()).addRow(row);
	IssueResolutionsList.getSelectionModel()
		.addListSelectionListener(new IssueTableSelectionListener(IssueResolutionsList, e, this));
	// IssueResolutionsList.setModel(new DefaultTableModel(data,
	// columnNames));

	IssueResolutionsList.getColumnModel().getColumn(0).setPreferredWidth(20);
	IssueResolutionsList.getColumnModel().getColumn(1).setPreferredWidth(20);
    }

    /*
     * public void loadActiveIssueResolutionsTable(List<IssueResolution>
     * activeIssueResolutions, EnsembleManager em) { Vector<Vector<String>> data
     * = convertAndFilterForJtable(activeIssueResolutions, em); // List of
     * Active Issue Resolutions Vector<String> columnNames = new
     * Vector<String>(); columnNames.add("Role Type"); columnNames.add("Role ID"
     * ); columnNames.add("Issue Type"); columnNames.add("Ensemble");
     * 
     * IssueResolutionsList = new JTable(data, columnNames) {
     * 
     * @Override public boolean isCellEditable(int r, int c) { return false; //
     * Disallow the editing of any cell }
     * 
     * }; IssueResolutionsList.setSelectionMode(ListSelectionModel.
     * SINGLE_INTERVAL_SELECTION); IssueResolutionsList.setBounds(5, 125, 400,
     * 400); IssueResolutionsList.setFillsViewportHeight(true);
     * IssueResolutionsList.getSelectionModel() .addListSelectionListener(new
     * IssueTableSelectionListener(IssueResolutionsList, em, this));
     * 
     * JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
     * tabbedPane.setBounds(5, 125, 400, 400); mainPanel.add(tabbedPane);
     * 
     * activeIssuesScrollPane = new JScrollPane(IssueResolutionsList);
     * tabbedPane.addTab("Active Issue Resolutions", null,
     * activeIssuesScrollPane, null); tabbedPane.setEnabledAt(0, true);
     * 
     * refreshWindow(); }
     */
    public void loadPlannerFrame(List<String> plans, Ensemble e) {
	Vector<Vector<String>> data = convertPlannerForJtable(plans);
	// List of Active Issue Resolutions
	Vector<String> columnNames = new Vector<String>();
	columnNames.add("State");

	planningList = new JTable(data, columnNames) {
	    @Override
	    public boolean isCellEditable(int r, int c) {
		return false; // Disallow the editing of any cell
	    }

	};
	planningList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
	planningList.setBounds(850, 310, 200, 130);
	planningList.setFillsViewportHeight(true);

	JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	tabbedPane.setBounds(850, 310, 200, 130);
	mainPanel.add(tabbedPane);

	plannerLogScrollPane = new JScrollPane(planningList);
	tabbedPane.addTab("Planning", null, plannerLogScrollPane, null);
	tabbedPane.setEnabledAt(0, true);

	refreshWindow();
    }

    public void loadExecuteFrame(List<String> exec, Ensemble e) {
	Vector<Vector<String>> data = convertExecuteForJtable(exec);
	// List of Active Issue Resolutions
	Vector<String> columnNames = new Vector<String>();
	columnNames.add("State");

	executeList = new JTable(data, columnNames) {
	    @Override
	    public boolean isCellEditable(int r, int c) {
		return false; // Disallow the editing of any cell
	    }

	};
	executeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
	executeList.setBounds(850, 125, 200, 130);
	executeList.setFillsViewportHeight(true);

	JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	tabbedPane.setBounds(850, 125, 200, 130);
	mainPanel.add(tabbedPane);

	executeLogScrollPane = new JScrollPane(executeList);
	tabbedPane.addTab("Executing", null, executeLogScrollPane, null);
	tabbedPane.setEnabledAt(0, true);

	refreshWindow();
    }

    public void updateActiveIssueResolutionTable(String capID, IssueResolution ir, EnsembleManager em) {

	String counter = Integer.toString(this.counter);
	Vector<String> row = convertAndFilterForJtable(counter, capID, ir, em);

	Vector<String> columnNames = new Vector<String>();
	columnNames.add("N");
	columnNames.add("Role Type");
	columnNames.add("Role ID");
	columnNames.add("Issue Type");
	columnNames.add("Ensemble");
	// IssueResolutionsList.setModel(new DefaultTableModel(row,
	// columnNames));

	refreshWindow();
    }

    public String getSelectedIssueInTable() {
	int sr = IssueResolutionsList.getSelectedRow();
	if (sr == -1 || sr >= IssueResolutionsList.getModel().getRowCount()) {
	    return "";
	}
	return (String) IssueResolutionsList.getModel().getValueAt(sr, 0);
    }

    public void resetIssueInstances() {
	IssueResolutionsList.setModel(null);

    }

    public void showTree(CATree cat) {

	// frame to see the issue resolution tree mxGraphComponent

	// cat.insertVertex(cat.getDefaultParent(), null, "ee", 0, 0, 80, 30,
	// null);
	// frame to see the issue resolution tree mxGraphComponent

	graphComponent.setGraph(cat);

	// layout = new mxParallelEdgeLayout(graphComponent.getGraph());

	// layout = new mxHierarchicalLayout(graphComponent.getGraph());

	graphComponent.setBounds(280, 125, 250, 400);
	graphComponent.setBorder(javax.swing.BorderFactory.createLineBorder(new Color(0, 0, 0)));

	graphComponent.setEnabled(true);
	layout.execute(graphComponent.getGraph().getDefaultParent());

    }

    public void refreshWindow() {
	mainPanel.validate();
	mainPanel.repaint();
    }

    public void resetTreeFrame() {
	if (graphComponent != null) {
	    graphComponent.removeAll();
	}
	refreshWindow();

    }

}